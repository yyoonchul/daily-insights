# 📰 Daily Digest — 2026-02-23

> 1건 정리 | AI

---

## 📋 간단 요약

### In software, the code documents the app. In AI, the traces do.
**출처:** LangChain Blog · **카테고리:** AI · **링크:** [원문](https://blog.langchain.com/in-software-the-code-documents-the-app-in-ai-the-traces-do/)
- AI 에이전트에서는 코드가 아닌 실행 트레이스가 시스템의 실제 동작을 문서화하는 핵심 수단이다
- 동일한 입력과 동일한 코드로도 다른 출력이 나올 수 있어 디버깅·테스트·모니터링 방식이 근본적으로 달라져야 한다
- Harrison Chase는 트레이스 기반 옵저버빌리티 인프라 없이는 에이전트 시스템의 실제 동작을 이해할 수 없다고 주장한다

---

## 📝 상세 정리

### 1. In software, the code documents the app. In AI, the traces do.

LangChain 창립자 Harrison Chase가 2026년 1월에 발표한 이 글은 전통적 소프트웨어와 AI 에이전트 시스템의 근본적 차이를 조명한다.

**핵심 전제: 코드 vs 트레이스**

- 전통적 소프트웨어에서는 코드가 곧 문서이자 로직의 원천이다
- AI 에이전트에서는 실제 의사결정이 런타임에 모델 내부에서 이루어진다
- 에이전트 코드는 모델, 도구, 지시문을 정의하는 "오케스트레이션 스캐폴딩"에 불과하다
- 어떤 도구를 쓸지, 언제 멈출지, 어떻게 추론할지는 모두 LLM이 런타임에 결정한다

**왜 코드만으로는 부족한가**

- 같은 입력 + 같은 코드로도 다른 출력이 나올 수 있다 (비결정적 특성)
- 코드 리뷰만으로는 에이전트의 실제 동작을 파악할 수 없다
- 트레이스가 도구 선택, 추론 체인, 타이밍, 결과를 완전히 기록한다

**실무 영향 6가지**

1. **디버깅**: 코드 검사 → 트레이스 분석으로 전환. 로직 에러가 아닌 추론 실패 지점을 추적한다
2. **테스트**: 평가(eval) 기반 접근. 프로덕션 트레이스를 데이터셋으로 캡처하여 품질 저하를 지속 모니터링한다
3. **성능 최적화**: 코드 프로파일링 → 의사결정 패턴 분석. 트레이스에서 비효율과 중복을 찾는다
4. **모니터링**: 업타임 추적 → 품질 평가. 작업 성공률과 추론 효과성을 측정한다
5. **협업**: 코드 리뷰 중심 → 옵저버빌리티 플랫폼 중심. 트레이스가 팀 논의의 공유 아티팩트가 된다
6. **프로덕트 분석**: 사용자 행동 이해를 위해 에이전트 의사결정 트레이스를 검토해야 한다

**실용적 제안**

- 구조화된 트레이싱 인프라 구축이 필수적이다
- 검색, 필터링, 비교 기능이 가능한 수준의 가시성이 필요하다
- 완전한 추론 체인, 도구 호출, 타이밍 데이터, 비용 메트릭에 대한 접근이 보장되어야 한다
- 옵저버빌리티 없이는 시스템의 실제 동작을 정의하는 문서 자체에 접근할 수 없다
